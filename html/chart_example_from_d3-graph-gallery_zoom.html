<html lang="en">
<div id="my_dataviz"></div>

<head>
  <meta charset="utf-8" />
  <script src="https://d3js.org/d3.v4.js"></script>
</head>

<body>
  <script>
   
      // set the dimensions and margins of the graph
    var margin = { top: 10, right: 30, bottom: 30, left: 60 };
    var bodyWidth = 500;
    var bodyHeight = 450;
    var lineWidth = 1.5;
    var maxScaleJ = 22.0;
    var ratioOccupyJgraph = 1.0 / 6.0;
    var circleRadius = 5;
    var spaceBetweenColumns = 3;
    var darkMode = false; // True not implemented
    //if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
    if (/Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
      circleRadius = 15;
      margin = { top: 10, right: 10, bottom: 30, left: 10 }; // For vertical
      bodyWidth = 800;
      bodyHeight = 1000; // Not good when horizontal....
      lineWidth = 5;
      ratioOccupyJgraph = 1.0 / 2.0;
      spaceBetweenColumns = spaceBetweenColumns / 2.0;
    }
    var circleRadiusSmall = circleRadius / 2;

    var width = bodyWidth - margin.left - margin.right;
    var height = bodyHeight - margin.top - margin.bottom;
    var heightJscale = height * ratioOccupyJgraph;

    var lineWidthCircle = lineWidth;
    var lineWidthColumn = lineWidth / 2;
    
    var lineWidthCircleSmall = lineWidth / 2;

    var preferedDistanceInPtBetweenColumns = 2.0 * (circleRadius) + lineWidthCircle + spaceBetweenColumns; // In pt
    
    var topJGraphYposition = 0;
    var bottomJGraphYposition = heightJscale;
    var pointingLineColum = bottomJGraphYposition + 20;

    function getJgraphColor(Jcoupling, darkmode) {
      // input
      // Color maps. First color for 0 Hz, second color for 2 Hz, etc. up to 20 Hz

      var colormap = [0, 1, 1, 0, 1, 0, 0.8, 0.8, 0, 0.9, 0.4, 0, 1, 0, 0, 1, 0, 0.5, 1, 0, 1, 0.5, 0, 1, 0, 0, 1, 0, 0, 0.5, 0, 0, 0]; // for white background
      if (darkmode) {
        colormap = [0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0.5, 0, 1, 0, 0, 1, 0, 0.5, 1, 0, 1, 0.5, 0, 0.9, 0.2, 0.2, 1, 0.4, 0.4, 0.5, 1, 1, 1]; // for black background
      }

      const JcouplingAbs = Math.abs(Jcoupling); // Hz
      var baseColorInt = Math.floor(JcouplingAbs / 2.0); // -20 - 20.0 ->  0 - 9 
      if (baseColorInt > 9) baseColorInt = 9; // baseColorInt 0 - 9
      var adjust = +(JcouplingAbs - 2.0 * baseColorInt) / 2.0; // normalized diff (0-1) for 2 Hz
      if (adjust > 1.0) adjust = 1.0; // adjust 0 - 1.0
      const baseColorIndex = 3 * baseColorInt; // 3 because RGB

      // the loop is language dependent, lets drop it...
      const r = Math.floor(+255.0 * colormap[baseColorIndex + 0] + adjust * (colormap[baseColorIndex + 3 + 0] - colormap[baseColorIndex + 0]));
      const g = Math.floor(+255.0 * colormap[baseColorIndex + 1] + adjust * (colormap[baseColorIndex + 3 + 1] - colormap[baseColorIndex + 1]));
      const b = Math.floor(+255.0 * colormap[baseColorIndex + 2] + adjust * (colormap[baseColorIndex + 3 + 2] - colormap[baseColorIndex + 2]));

      //const negExpVal = (Jcoupling < 0.0); // used to change line type for negative values.                   

      return (["rgb(",r,",",g,",",b,")"].join(""));
    }
/*
    const jcccol = getJgraphColor(11.2, darkMode);
    console.log("getJgraphColor :jcccol " + jcccol);
*/
    // append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform",
        "translate(" + margin.left + "," + margin.top + ")");
    d3.csv("./andro.csv", function (jGraphData) {
      // get chemical shifts from lines... should come from other source !
      var arrayColumns = [];
      var unassignedCouplings = []; // marked with label "noAssignement" in file
      var theAssignedCouplings = [];
      {
        var curChemShiftToReplace = [];
        var indexArray = [];
        curChemShiftToReplace = jGraphData.map(function (d) { return d.chemShift1; })
        indexArray = jGraphData.map(function (d) { return d.indexColumn1; })
        label = jGraphData.map(function (d) { return d.Label; })
        Jvalue = jGraphData.map(function (d) { return d.Jvalue; })
        JvalueShifted = jGraphData.map(function (d) { return d.JvalueShifted; })
        indexColumn1 = jGraphData.map(function (d) { return d.indexColumn1; })
        indexColumn2 = jGraphData.map(function (d) { return d.indexColumn2; })
        //index 1
        for (i = 0; i < curChemShiftToReplace.length; i++) {
          const index = indexArray[i];
          arrayColumns[index - 1] = curChemShiftToReplace[i];
          if (label[i] == "noAssignement") {
            unassignedCouplings.push({ Jvalue: +Jvalue[i], colNumber: (index - 1) })
          } else {
            theAssignedCouplings.push({ 
              Jvalue: +Jvalue[i], 
              colNumber: (index - 1),
              Label: label[i],
              JvalueShifted: +JvalueShifted[i],
              indexColumn1: indexColumn1[i],
              indexColumn2: indexColumn2[i],
              })
          }
        }
        // index 2
        curChemShiftToReplace = jGraphData.map(function (d) { return d.chemShift2; })
        indexArray = jGraphData.map(function (d) { return d.indexColumn2; })
        for (i = 0; i < indexArray.length; i++) {
          const index = indexArray[i];
          arrayColumns[index - 1] = curChemShiftToReplace[i];
          if (label[i] == "noAssignement") {
            unassignedCouplings.push({ Jvalue: +Jvalue[i], colNumber: (index - 1) })
          } else {
            theAssignedCouplings.push({
              Jvalue: +Jvalue[i], 
              colNumber: (index - 1),
              Label: label[i],
              JvalueShifted: +JvalueShifted[i],
              indexColumn1: indexColumn1[i],
              indexColumn2: indexColumn2[i],
              })
           }
        }
      }
      console.log("unassignedCouplings :" + JSON.stringify(unassignedCouplings))
      console.log("arrayColumns1 " + arrayColumns);

      // sort by decreasing values
      var len = arrayColumns.length;
      var indices = new Array(len);
      for (var i = 0; i < len; ++i) indices[i] = i;
      indices.sort(function (a, b) { return arrayColumns[a] < arrayColumns[b] ? 1 : arrayColumns[a] > arrayColumns[b] ? -1 : 0; });
      //  console.log("arrayColumns indices " + indices);
      // console.log("arrayColumns2 " + arrayColumns);
      //arrayColumns.sort().reverse();
      var indices2 = new Array(len);
      for (var i = 0; i < len; ++i) indices2[indices[i]] = i;
      var indices3 = new Array(len); for (var i = 0; i < len; ++i) indices3[i] = indices[i];
      //  console.log("arrayColumns indices2 " + indices2);
      //  console.log("arrayColumns indices3 " + indices3);

      // renumber index jGraphData(from 0 instread of 1 and decreasing chemical shift)
      for (var i = 0; i < jGraphData.length; ++i) {
        //  console.log("arrayColumnsTTTT  " + i + " " + jGraphData[i].indexColumn1);
        jGraphData[i].indexColumn1 = indices2[jGraphData[i].indexColumn1 - 1];
        jGraphData[i].indexColumn2 = indices2[jGraphData[i].indexColumn2 - 1];
      }

      var dataColumns = [];
      for (i = 0; i < arrayColumns.length; i++) {
        dataColumns.push({
          'chemShift': arrayColumns[indices[i]],
          'MyIndex': i,
        });
      }

      var dataUnassignedCoupCircles = [];
      for (i = 0; i < unassignedCouplings.length; i++) {
        const inInd = indices2[unassignedCouplings[i].colNumber];
        dataUnassignedCoupCircles.push({
          'chemShift': arrayColumns[inInd],
          'value': unassignedCouplings[i].Jvalue,
          'MyIndex': inInd,
        });
      }

      var dataAssignedCoupCircles = [];
      for (i = 0; i < theAssignedCouplings.length; i++) {
        const inInd = indices2[theAssignedCouplings[i].colNumber];
        dataAssignedCoupCircles.push({
          'chemShift': arrayColumns[inInd],
          'value': theAssignedCouplings[i].Jvalue,
          'MyIndex': inInd,
        });
      }


      // Make list of positions accoding to size of jGraphData
      const numberItem = arrayColumns.length;  //
      var smallSpace = width / (numberItem + 1); // five items, six spaces
      if (smallSpace > preferedDistanceInPtBetweenColumns) {
        smallSpace = preferedDistanceInPtBetweenColumns;
      }

      var leftPosColumns = [];
      var rightPosColumns = [];
      for (i = 0; i < numberItem; i++) {
        const curPosLeft = (i + 0.5) * smallSpace;
        const curPosRight = width - ((numberItem - i) - 0.5) * smallSpace;
        leftPosColumns.push(curPosLeft);
        rightPosColumns.push(curPosRight);
      }

      console.log("Left pos :" + JSON.stringify(leftPosColumns))
      console.log("Right pos :" + JSON.stringify(rightPosColumns))

      var color = d3.scaleOrdinal()
        .domain(["sefsdosa", "versifsdcolor", "vigdfginica", "asdf"]) // colors do not need to match the ones of the file only the numver in the file matters
        // .range([ "#440154ff", "#21908dff", "#fde725ff", "red"]) // fourth color
        .range(["orange", "green", "blue", "red", "#440154ff", "#21908dff", "#fde725ff", "orange", "cyan", "magenta", "black", "gray"]) // fourth color
      //listOfChemicalShifts = ["chemShift1","chemShift2"]
      // listOfPosition = ["JvalueShif","JvalueShifted","y3","y4"]
      /*
             for (var key in dataLines[0]) {
             listOfChemicalShifts.push(key)
        }
        for (var key in dataLines[0]) {
             listOfChemicalShifts.push(key)
        }
        listOfChemicalShifts.pop()
      */
      // Highlight the specie that is hovered
      var highlight = function (d) {
        selected_specie = d.Label
        // first every group turns grey
        d3.selectAll(".line")
          .transition().duration(200)
          .style("stroke", "black")
          .style("opacity", "0.2")
        // Second the hovered specie takes its color
        d3.selectAll("." + selected_specie)
          .transition().duration(200)
        //  .style("stroke", color(selected_specie))
        //.style("stroke", getJgraphColor(d.Jvalue, darkMode))
        .style("stroke", function (d) { return getJgraphColor(d.Jvalue, darkMode); })

          .style("opacity", "1")
      }

      // Unhighlight
      var doNotHighlight = function (d) {
        d3.selectAll(".line")
          .transition().duration(200).delay(1000)
       //   .style("stroke", function (d) { return (color(d.Label)) })
         // .style("stroke", function (d) { return getJgraphColor(d.Jvalue, darkMode) })
         .style("stroke", function (d) { return getJgraphColor(d.Jvalue, darkMode); })
         .style("opacity", "1")
      }

      var highlightDot = function (d) {

        selected_specie = d.Label
        // first every group turns grey
        d3.selectAll(".circleL")
          .transition().duration(200)
          .style("stroke", "black")
          .style("opacity", "0.2")
        // Second the hovered specie takes its color
        d3.selectAll("." + selected_specie)
          .transition().duration(200)
         // .style("stroke", color(selected_specie))
          .style("stroke", "red")
          .style("opacity", "1")
      }
      // Unhighlight
      var doNotHighlightDot = function (d) {
        d3.selectAll(".circleL")
          .transition().duration(200).delay(1000)
          .style("stroke", function (d) { return (color(d.Label)) })
          .style("opacity", "1")
      }

 d3.csv("./Androsten_forMult_analysis.csv",
        // format variables:
        function (d) {
          return { chemShift: d.x, value: d.y }
        },

        function (chemShift) {
          // Add X axis 
          var x = d3.scaleLinear()
            .domain([
              d3.max(chemShift, function (d) { return +d.chemShift; }),
              d3.min(chemShift, function (d) { return +d.chemShift; })
            ])
            .range([0, width]);
          xAxis = svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));

          // Add Y axis2
          var yJs = d3.scaleLinear()
            .domain([0, maxScaleJ])
            .range([heightJscale, 0.0]);
          yAxisn = svg.append("g")
            // .attr("transform", function(d) { return "translate(" + x(5.5) + ")"; })
            .call(d3.axisLeft(yJs).ticks(3));

          yAxisn2 = svg.append("g")
            .attr("transform", function (d) { return "translate(" + (width) + ")"; })
            .call(d3.axisRight(yJs).ticks(3))
            ;

          let dimensions = [1, 1.2, 1.3, 2, 3, 5];

          var yn = {}
          for (i in dimensions) {
            name = dimensions[i]
            yn[name] = d3.scaleLinear()
              .domain([0.0, 22.0]) // --> Same axis range for each group
              // --> different axis range for each group --> .domain( [d3.extent(data, function(d) { return +d[name]; })] )
              .range([height / 3.0, height / 6.0]);
          }
          // Add Y axis
          var y = d3.scaleLinear()
            .domain([0, d3.max(chemShift, function (d) { return +d.value; })])
            .range([height, 0]);
          //yAxis = svg.append("g") .call(d3.axisLeft(y));

          // Add a clipPath: everything out of this area won't be drawn.
          var clip = svg.append("defs").append("svg:clipPath")
            .attr("id", "clip")
            .append("svg:rect")
            .attr("width", width)
            .attr("height", height)
            .attr("x", 0)
            .attr("y", 0);

          // Add brushing
          var brush = d3.brushX()                   // Add the brush feature using the d3.brush function
            .extent([[0, 0], [width, height]])  // initialize the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
            .on("end", updateChart)               // Each time the brush selection changes, trigger the 'updateChart' function

          // Create the line variable: where both the line and the brush take place
          var lineSpectrum = svg.append('g')
            .attr("clip-path", "url(#clip)")

          // Add the spectrum
          lineSpectrum.append("path")
            .datum(chemShift)
            .attr("class", "lineG")  // add the class line to be able to modify this line later on.
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            // .attr("stroke", "red")
            .attr("stroke-width", lineWidth)
            .attr("d", d3.line()
              .x(function (d) { return x(d.chemShift) })
              .y(function (d) { return y(d.value) })
            )

          // level of tickLine
          var dataTicksLines = [
            { Jval: 0 },
            { Jval: 5 },
            { Jval: 10 },
            { Jval: 15 },
            { Jval: 20 },
          ];

          var theTicksLines = svg.selectAll("tickLines")
            .data(dataTicksLines)
            .enter()
            .append("line")
            .attr("class", "Grid")
            .attr("x1", 0)
            .attr("y1", function (d) { return yJs(d.Jval); })
            .attr("x2", width)
            .attr("y2", function (d) { return yJs(d.Jval); })
            .attr("stroke", "#CCCCCC")
            .style("stroke-width", lineWidth)

          // Columns
          const colorShowLine = "#CCCCCC";
          const colorHideLine = "#EEEEEE00";
          // oblique
          var spreadPositionsUU = updateColumns222();

          var theColumns1 = svg.selectAll("columnns")
            .data(dataColumns)
            .enter()
            .append("line")
            .attr("class", "ColunnSegment1")
            .attr("x1", function (d) { return spreadPositionsUU[d.MyIndex]; })
            .attr("x2", function (d) { return spreadPositionsUU[d.MyIndex]; })
            .attr("y1", function (d) { return bottomJGraphYposition; })
            .attr("y2", function (d) { return pointingLineColum; })
            .attr("stroke", colorHideLine) // just sketched... update wil fix colors
            .style("stroke-width", lineWidthCircle)
          // streight down
          var theColumns2 = svg.selectAll("ColunnSegment2")
            .data(dataColumns)
            .enter()
            .append("line")
            .attr("class", "Colunn")
            .attr("x1", function (d) { return spreadPositionsUU[d.MyIndex]; })
            .attr("x2", function (d) { return spreadPositionsUU[d.MyIndex]; })
            .attr("y1", function (d) { return pointingLineColum; })
            .attr("y2", function (d) { return height; })
            .attr("stroke", colorHideLine) // just sketched... update wil fix colors
            .style("stroke-width", lineWidthCircle)

            var theColumns3 = svg.selectAll("ColunnSegment3")
            .data(dataColumns)
            .enter()
            .append("line")
            .attr("class", "Colunn")
            .attr("x1", function (d) { return spreadPositionsUU[d.MyIndex]; })
            .attr("x2", function (d) { return spreadPositionsUU[d.MyIndex]; })
            .attr("y1", function (d) { return topJGraphYposition; })
            .attr("y2", function (d) { return bottomJGraphYposition; })
            .attr("stroke", "black") // just sketched... update wil fix colors
            .style("stroke-width", lineWidthColumn)

            var theColumns4 = svg.selectAll("ColunnSegment4")
            .data(dataColumns)
            .enter()
            .append("line")
            .attr("class", "Colunn")
            .attr("x1", function (d) { return spreadPositionsUU[d.MyIndex] + circleRadius; })
            .attr("x2", function (d) { return spreadPositionsUU[d.MyIndex] - circleRadius; })
            .attr("y1", function (d) { return bottomJGraphYposition; })
            .attr("y2", function (d) { return bottomJGraphYposition; })
            .attr("stroke", "black") // just sketched... update wil fix colors
            .style("stroke-width", lineWidthCircle)


          // Lines
          function pathFun(d) {

            // var pathOx = listOfChemicalShifts.map(function(p) { return x(d[p]); });
            console.log(JSON.stringify(d))
            const y1 = yJs(d.Jvalue);
            const y2 = yJs(d.JvalueShifted);
            //const horizontalShiftX = 0.01;
            const horizontalShiftX = 2;
            var usedHorizontalShiftX = eval(horizontalShiftX);
            const cs1 = spreadPositionsZZ[d.indexColumn1];
            const cs2 = spreadPositionsZZ[d.indexColumn2];
            if (cs1 > cs2) {
              var usedHorizontalShiftX = eval(- usedHorizontalShiftX);
            }
            const x1 = ((cs1));
            const x2 = ((cs2));
            const x1p = ((cs1) + usedHorizontalShiftX);
            const x2p = ((cs2) - usedHorizontalShiftX);
            /*
            if (d.chemShift1 > d.chemShift2) {
               var usedHorizontalShiftX = eval(- usedHorizontalShiftX);
             } const x1 = x(eval(d.chemShift1));
             const x2 = x(eval(d.chemShift2));
             const x1p = x(eval(d.chemShift1) + usedHorizontalShiftX);
             const x2p = x(eval(d.chemShift2) - usedHorizontalShiftX);
 */
            const combine = [[x1, y1], [x1p, y2], [x2p, y2], [x2, y1]];
            var Gen = d3.line();
            /*Gen.attr("d", d3.line()
                    .x(function(d) { return x(pathOx) })
               .y(function(d) { return yJs(pathOy) })
             )*/
            return Gen(combine);
          }
          /*
          function pathx(d) {
            console.log("pathx")
            console.log(JSON.stringify(d))
             console.log("pathxo")
            console.log(JSON.stringify(listOfChemicalShifts.map(function(p) { return x(p); })))
               return listOfChemicalShifts.map(function(p) { return x(p); });
          }
          function pathy(d) {
            console.log("pathy")
            console.log(JSON.stringify(d))
            console.log("pathyo")
            console.log(JSON.stringify(listOfChemicalShifts.map(function(p) { return yJs(d[p]); })))
               return listOfChemicalShifts.map(function(p) { return yJs(d[p]); });
          }
          */

          function getSpread(spreadDelta, smallSpace) {
            // determine how to spead objects to avoid contacts
            // there muss be anough space for this function to work
            for (i = 0; i < spreadDelta.length; i++) {
              const curDelta = spreadDelta[i];
              if (curDelta < smallSpace) {
                const spreadFull = (smallSpace - curDelta);
                var spreadleft = spreadFull / 2.0;
                // try shift left (1 of 3)
                for (j = i - 1; j >= 0; j -= 1) {
                  const curExtraSpace = (spreadDelta[j] - smallSpace);
                  if (curExtraSpace > 0.0) {
                    if (curExtraSpace > spreadleft) {
                      spreadDelta[j] -= spreadleft;
                      spreadDelta[i] += spreadleft;
                      spreadleft = 0;
                    } else {
                      spreadDelta[j] -= curExtraSpace;
                      spreadDelta[i] += curExtraSpace;
                      spreadleft -= curExtraSpace;
                    }
                  }
                }
                // work left over
                var spreadRight = spreadFull - spreadleft;
                // try shift right (2 of 3)
                for (j = i + 1; j < spreadDelta.length; j += 1) {
                  const curExtraSpace = (spreadDelta[j] - smallSpace);
                  if (curExtraSpace > 0.0) {
                    if (curExtraSpace > spreadRight) {
                      spreadDelta[j] -= spreadRight;
                      spreadDelta[i] += spreadRight;
                      spreadRight = 0;
                    } else {
                      spreadDelta[j] -= curExtraSpace;
                      spreadDelta[i] += curExtraSpace;
                      spreadRight -= curExtraSpace;
                    }
                  }
                }
                // work left over (rare but there may be a left over....)
                if (spreadRight > 0.0) {
                  spreadleft = spreadRight;
                  // try shift left (3 of 3)
                  for (j = i - 1; j >= 0; j -= 1) {
                    const curExtraSpace = (spreadDelta[j] - smallSpace);
                    if (curExtraSpace > 0.0) {
                      if (curExtraSpace > spreadleft) {
                        spreadDelta[j] -= spreadleft;
                        spreadDelta[i] += spreadleft;
                        spreadleft = 0;
                      } else {
                        spreadDelta[j] -= curExtraSpace;
                        spreadDelta[i] += curExtraSpace;
                        spreadleft -= curExtraSpace;
                      }
                    }
                  }
                }
                // Done 3/3
              }
            }
            return spreadDelta;
          }


          function updateColumns333(spreadPositions, timeAnimation) {

            theColumns1
              .transition().duration(timeAnimation)
              .attr("x1", function (d) {return spreadPositions[d.MyIndex];})
              .attr("x2", function (d) {return x(d.chemShift);})
              .attr("stroke", function (d) {
                if ((x(d.chemShift) > 0.0) &&(x(d.chemShift) < width)) {return colorShowLine;
                } else { return colorHideLine; }
              })

            theColumns2
              .transition().duration(timeAnimation)
              .attr("x1", function (d) { return x(d.chemShift); })
              .attr("x2", function (d) { return x(d.chemShift); })
              .attr("stroke", function (d) {
                if ((x(d.chemShift) > 0.0) && (x(d.chemShift) < width)) {
                  return colorShowLine;
                } else { return colorHideLine; }
              })

            theColumns3
              .transition().duration(timeAnimation)
              .attr("x1", function (d) { return spreadPositions[d.MyIndex]; })
              .attr("x2", function (d) { return spreadPositions[d.MyIndex]; })
              .attr("stroke", function (d) {
                return "black";
              })

            theColumns4
              .transition().duration(timeAnimation)
              .attr("x1", function (d) { return spreadPositions[d.MyIndex] + circleRadius; })
              .attr("x2", function (d) { return spreadPositions[d.MyIndex] - circleRadius; })
              .attr("stroke", function (d) {
                return "black";
              })

            theDots
              .transition().duration(timeAnimation)
              .attr("cx", function (d) { return spreadPositions[d.MyIndex]; })

            theDots2
              .transition().duration(timeAnimation)
              .attr("cx", function (d) {
                return spreadPositions[d.MyIndex];
              })

          }
          function updateColumns222() {
            spreadPositions = [];
            spreadDelta = [];
            for (i = 0; i < dataColumns.length; i++) {
              var returnValue = 0.0;
              const curChemShift = dataColumns.map(function (d) { return d.chemShift; })
              const curChem = curChemShift[i];
              if (leftPosColumns[i] < x(curChem)) {
                if (rightPosColumns[i] > x(curChem)) {
                  returnValue = x(curChem);
                } else {
                  returnValue = rightPosColumns[i];
                }
              } else {
                returnValue = leftPosColumns[i];
              }
              spreadPositions.push(returnValue);
              if (i > 0) {
                spreadDelta.push(returnValue - spreadPositions[i - 1]);
              }
            }
            console.log("spreadPositions  " + JSON.stringify(spreadPositions))
            console.log("spreadDelta  " + JSON.stringify(spreadDelta))
            // See if need to seprated in the central region.
            spreadDelta = getSpread(spreadDelta, smallSpace);
            console.log("spreadDeltaspreadDelta  " + JSON.stringify(spreadDelta))

            for (i = 0; i < spreadDelta.length; i++) {
              spreadPositions[i + 1] = spreadPositions[i] + spreadDelta[i];
            }


            return spreadPositions;
          }
          var spreadPositionsZZ = updateColumns222();
          var theLinesW = svg
            .selectAll("myPath222")
            .attr("class", "lineW")
          .data(jGraphData)
          //  .data(theAssignedCouplings)
            .enter()
            .append("path")
            .attr("class", function (d) { return "line " + d.Label }) // 2 class for each line: 'line' and the group name
            //.attr("d", function (d) { return d3.line()(listOfChemicalShifts.map(function(p) { return [x(p), yJs(d[p])]; })); })
            .attr("d", pathFun)
            .style("stroke-width", lineWidth)
            /*.attr("d", d3.line()
              //.x(pathx)
              .x(function(d){ listOfChemicalShifts.map(function(p) { return x(p); }); })
              //.y(pathy)
              .y(function(d){ listOfChemicalShifts.map(function(p) { return yJs(d[p]); }) })
            )*/
            .style("fill", "none")
            .style("stroke", function (d) { return (color(d.Label)) })
            .style("opacity", 0.5)
            .on("mouseover", highlight)
            .on("mouseleave", doNotHighlight)


           
          // Circles
          var theDots = svg.selectAll("dots")
            .data(dataUnassignedCoupCircles)
            .enter()
            .append("circle")
            .attr("class", "circleL")
            .attr("cx", function (d) { return x(d.chemShift); })
            .attr("cy", function (d) { return yJs(d.value); })
            .attr("r", circleRadius)
            //.style("fill", "white")
            .style("fill", function (d) { return getJgraphColor(d.value, darkMode); })
            .attr("stroke", "black")
            .style("stroke-width", lineWidthCircle)
            .on("mouseover", highlightDot)
            .on("mouseleave", doNotHighlightDot)

          // Dots
          var theDots2 = svg.selectAll("dots")
            .data(dataAssignedCoupCircles)
            .enter()
            .append("circle")
            .attr("class", "circleS")
            .attr("cx", function (d) { return x(d.chemShift); })
            .attr("cy", function (d) { return yJs(d.value); })
            .attr("r", circleRadiusSmall)
            .style("fill", "gray")
            .attr("stroke", "black")
            .style("stroke-width", lineWidthCircleSmall)
           
            var theTextDots2 = svg.selectAll("textt")
            .data(dataAssignedCoupCircles)
            .enter()
            .append("text")
            .attr("class", "circleS")
            .attr("x", function (d) { return x(d.chemShift); })
            .attr("y", function (d) { return yJs(d.value); })
           // .style("fill", "gray")
          //  .attr("stroke", "black")
         // .style("stroke-width", lineWidthCircleSmall)
          .text("stroke-width")
          .attr('dy', '.35em')
  .style("font-size",8)
  .attr("transform", function(d) {return "rotate("+45+","+10+",00)";});

          updateColumns333(spreadPositionsZZ, 0);


          // Add the brushing
          lineSpectrum
            .append("g")
            .attr("class", "brush")
            .call(brush);



          // A function that set idleTimeOut to null
          var idleTimeout
          function idled() { idleTimeout = null; }

          // A function that update the chart for given boundaries
          function updateChart() {
            console.log("Function updateChart ...===========")

            // What are the selected boundaries?
            extent = d3.event.selection

            // If no selection, back to initial coordinate. Otherwise, update X axis domain
            if (!extent) {
              if (!idleTimeout) return idleTimeout = setTimeout(idled, 350); // This allows to wait a little bit
              x.domain([
                d3.max(chemShift, function (d) { return +d.chemShift; }),
                d3.min(chemShift, function (d) { return +d.chemShift; })
              ])
            } else {
              x.domain([
                x.invert(extent[0]),
                x.invert(extent[1])
              ])
              lineSpectrum.select(".brush").call(brush.move, null) // This remove the grey brush area as soon as the selection has been done
            }

            // Update axis and line position
            xAxis.transition().duration(1000).call(d3.axisBottom(x))
            //xAxis2.transition().duration(1000).call(d3.axisBottom(x))

            lineSpectrum
              .select('.lineG')
              .transition().duration(1000)
              .attr("d", d3.line()
                .x(function (d) { return x(d.chemShift) })
                .y(function (d) { return y(d.value) })
              )


            spreadPositionsZZ = updateColumns222();
            updateColumns333(spreadPositionsZZ, 1000);
            theLinesW
              //.select('.lineW')
              .transition().duration(1000)
              .attr("d", pathFun)
            /*
                        console.log("x2Line grasss :" + JSON.stringify(
                          (dataCircles.map(function (d) {
                            //console.log("ch " + d.MyIndex);
                            //  console.log("x " + x(d.MyIndex));
                            return d.index;
                          }))
                        ))
            */

            //.attr("cx", x(5.555))
            /*   console.log(JSON.stringify(
                 (theDots.attr("cx"))
               ))
   
   */

            /*       console.log("chem :" + JSON.stringify(
                     (dataCircles.map(function (d) {
                       // console.log("ch" + d.chemShift);
                       return d.chemShift;
                     }))
                   ))
                   console.log("index :" + JSON.stringify(
                     (dataCircles.map(function (d) {
                       //console.log("ch " + d.MyIndex);
                       //  console.log("x " + x(d.MyIndex));
                       return d.index;
                     }))
                   ))
       */
          }
          // If user double click, reinitialize the chart
          svg.on("dblclick", function () {
            x.domain([
              d3.max(chemShift, function (d) { return +d.chemShift; }),
              d3.min(chemShift, function (d) { return +d.chemShift; })
            ])
            xAxis.transition().call(d3.axisBottom(x))

            lineSpectrum
              .select('.line')
              .transition()
              .attr("d", d3.line()
                .x(function (d) { return x(d.chemShift) })
                .y(function (d) { return y(d.value) })
              )
          });


        })
    })


  </script>
  <h2>J Graph v0.1</h2>
  <h3>To do</h3>
  <h4> Roll over (or click?) unassigned J's:</h4>
  <p>- Draw horizontal line  </p>
  <p>- Highligh possible partners frame : green when only one possibility....  </p>
<p>(eventually allow to make pair....)</p>
<h4> Add spin label on top of column</h4>
<p>- ...  </p>

</body>

</html>