<html lang="en">
<div id="my_dataviz"></div>

<head>
  <meta charset="utf-8" />
  <script src="https://d3js.org/d3.v4.js"></script>
</head>

<body>
  <script>

    // set the dimensions and margins of the graph
    var margin = { top: 10, right: 30, bottom: 30, left: 60 };
    var bodyWidth = 500;
    var bodyHeight = 450;
    var lineWidth = 1.5;
    var maxScaleJ = 22.0;
    var ratioOccupyJgraph = 1.0 / 6.0;
    var circleRadius = 5;

    //if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
    if (/Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
      circleRadius = 15;
      margin = { top: 10, right: 10, bottom: 30, left: 10 }; // For vertical
      bodyWidth = 800;
      bodyHeight = 1000; // Not good when horizontal....
      lineWidth = 5;
      ratioOccupyJgraph = 1.0 / 2.0;
    }

    var width = bodyWidth - margin.left - margin.right;
    var height = bodyHeight - margin.top - margin.bottom;
    var heightJscale = height * ratioOccupyJgraph;

    var lineWidthCircle = lineWidth;
    var preferedDistanceInPtBetweenColumns = 2.0 * (circleRadius) + lineWidthCircle; // In pt
    var bottomJGraphYposition = heightJscale;
    var pointingLineColum = bottomJGraphYposition + 20;

    // append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform",
        "translate(" + margin.left + "," + margin.top + ")");
    d3.csv("./andro.csv", function (jGraphData) {

      var arrayChemicalShiftsFromLines = [];
      {
        var curChemShiftToReplace = [];
        var indexArray = [];
        curChemShiftToReplace = jGraphData.map(function (d) { return d.chemShift1; })
        indexArray = jGraphData.map(function (d) { return d.indexColumn1; })
        //index 1
        for (i = 0; i < curChemShiftToReplace.length; i++) {
          const index = indexArray[i];
          //dataCircles[index].chemShift = curChemShiftToReplace[i];
          arrayChemicalShiftsFromLines[index - 1] = curChemShiftToReplace[i];
        }
        // index 2
        curChemShiftToReplace = jGraphData.map(function (d) { return d.chemShift2; })
        indexArray = jGraphData.map(function (d) { return d.indexColumn2; })
        for (i = 0; i < indexArray.length; i++) {
          const index = indexArray[i];
          //dataCircles[index].chemShift = curChemShiftToReplace[i];
          arrayChemicalShiftsFromLines[index - 1] = curChemShiftToReplace[i];
        }
      }
      arrayChemicalShiftsFromLines.sort();
      arrayChemicalShiftsFromLines.reverse();
      console.log("arrayChemicalShiftsFromLines  " + JSON.stringify(arrayChemicalShiftsFromLines))

      var dataCircles = new Array(arrayChemicalShiftsFromLines.length);

      for (i = 0; i < arrayChemicalShiftsFromLines.length; i++) {
        dataCircles[i] = {
          'chemShift': arrayChemicalShiftsFromLines[i],
          'value': 0.0,
          'MyIndex': i,
        };
      }


      // Make list of positions accoding to size of jGraphData
      const numberItem = dataCircles.length;  // this will be size of jGraphData
      var smallSpace = width / (numberItem + 1); // five items, six spaces
      if (smallSpace > preferedDistanceInPtBetweenColumns) {
        smallSpace = preferedDistanceInPtBetweenColumns;
      }



      console.log("=====================")

      var leftPosColumns = [];
      var rightPosColumns = [];
      for (i = 0; i < numberItem; i++) {
        const curPosLeft = (i + 0.5) * smallSpace;
        const curPosRight = width - ((numberItem - i) - 0.5) * smallSpace;
        leftPosColumns.push(curPosLeft);
        rightPosColumns.push(curPosRight);
      }

      console.log("Left pos :" + JSON.stringify(leftPosColumns))
      console.log("Right pos :" + JSON.stringify(rightPosColumns))

      var color = d3.scaleOrdinal()
        .domain(["sefsdosa", "versifsdcolor", "vigdfginica", "asdf"]) // colors do not need to match the ones of the file only the numver in the file matters
        // .range([ "#440154ff", "#21908dff", "#fde725ff", "red"]) // fourth color
        .range(["orange", "green", "blue", "red"]) // fourth color
      //listOfChemicalShifts = ["chemShift1","chemShift2"]
      // listOfPosition = ["JvalueShif","JvalueShifted","y3","y4"]
      /*
        for (var key in dataLines[0]) {
             listOfChemicalShifts.push(key)
        }
        for (var key in dataLines[0]) {
             listOfChemicalShifts.push(key)
        }
        listOfChemicalShifts.pop()
      */
      // Highlight the specie that is hovered
      var highlight = function (d) {

        selected_specie = d.Label
        // first every group turns grey
        d3.selectAll(".line")
          .transition().duration(200)
          .style("stroke", "black")
          .style("opacity", "0.2")
        // Second the hovered specie takes its color
        d3.selectAll("." + selected_specie)
          .transition().duration(200)
          .style("stroke", color(selected_specie))
          .style("opacity", "1")
      }

      // Unhighlight
      var doNotHighlight = function (d) {
        d3.selectAll(".line")
          .transition().duration(200).delay(1000)
          .style("stroke", function (d) { return (color(d.Label)) })
          .style("opacity", "1")
      }

      d3.csv("./Androsten_forMult_analysis.csv",
        // format variables:
        function (d) {
          return { chemShift: d.x, value: d.y }
        },

        function (chemShift) {
          // Add X axis 
          var x = d3.scaleLinear()
            .domain([
              d3.max(chemShift, function (d) { return +d.chemShift; }),
              d3.min(chemShift, function (d) { return +d.chemShift; })
            ])
            .range([0, width]);
          xAxis = svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));

          // Add Y axis2
          var yJs = d3.scaleLinear()
            .domain([0, maxScaleJ])
            .range([heightJscale, 0.0]);
          yAxisn = svg.append("g")
            // .attr("transform", function(d) { return "translate(" + x(5.5) + ")"; })
            .call(d3.axisLeft(yJs).ticks(3));

          yAxisn2 = svg.append("g")
            .attr("transform", function (d) { return "translate(" + (width) + ")"; })
            .call(d3.axisRight(yJs).ticks(3))
            ;

          let dimensions = [1, 1.2, 1.3, 2, 3, 5];

          var yn = {}
          for (i in dimensions) {
            name = dimensions[i]
            yn[name] = d3.scaleLinear()
              .domain([0.0, 22.0]) // --> Same axis range for each group
              // --> different axis range for each group --> .domain( [d3.extent(data, function(d) { return +d[name]; })] )
              .range([height / 3.0, height / 6.0]);
          }
          // Add Y axis
          var y = d3.scaleLinear()
            .domain([0, d3.max(chemShift, function (d) { return +d.value; })])
            .range([height, 0]);
          //yAxis = svg.append("g") .call(d3.axisLeft(y));

          // Add a clipPath: everything out of this area won't be drawn.
          var clip = svg.append("defs").append("svg:clipPath")
            .attr("id", "clip")
            .append("svg:rect")
            .attr("width", width)
            .attr("height", height)
            .attr("x", 0)
            .attr("y", 0);

          // Add brushing
          var brush = d3.brushX()                   // Add the brush feature using the d3.brush function
            .extent([[0, 0], [width, height]])  // initialize the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
            .on("end", updateChart)               // Each time the brush selection changes, trigger the 'updateChart' function

          // Create the line variable: where both the line and the brush take place
          var line = svg.append('g')
            .attr("clip-path", "url(#clip)")

          // Add the spectrum
          line.append("path")
            .datum(chemShift)
            .attr("class", "lineG")  // add the class line to be able to modify this line later on.
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            // .attr("stroke", "red")
            .attr("stroke-width", lineWidth)
            .attr("d", d3.line()
              .x(function (d) { return x(d.chemShift) })
              .y(function (d) { return y(d.value) })
            )

          var dataTicksLines = [
            { Jval: 0 },
            { Jval: 5 },
            { Jval: 10 },
            { Jval: 15 },
            { Jval: 20 },
          ]

          var theTicksLines = svg.selectAll("tickLines")
            .data(dataTicksLines)
            .enter()
            .append("line")
            .attr("class", "Grid")
            .attr("x1", 0)
            .attr("y1", function (d) { return yJs(d.Jval); })
            .attr("x2", width)
            .attr("y2", function (d) { return yJs(d.Jval); })
            .attr("stroke", "#CCCCCC")
            .style("stroke-width", lineWidth)


          // Circles
          var theDots = svg.selectAll("dots")
            .data(dataCircles)
            .enter()
            .append("circle")
            .attr("class", "circle")
            .attr("cx", function (d) { return x(d.chemShift); })
            .attr("cy", function (d) { return yJs(d.value); })
            .attr("r", circleRadius)
            .style("fill", "#69b3a2")
            .attr("stroke", "red")
            .style("stroke-width", lineWidthCircle)

          // Columns
          const colorShowLine = "#CCCCCC";
          const colorHideLine = "#EEEEEE00";
          // oblique
          var theColumns1 = svg.selectAll("columnns")
            .data(dataCircles)
            .enter()
            .append("line")
            .attr("class", "ColunnSegment1")
            .attr("x1", function (d) { return x(d.chemShift); })
            .attr("x2", function (d) { return x(d.chemShift); })
            .attr("y1", function (d) { return bottomJGraphYposition; })
            .attr("y2", function (d) { return pointingLineColum; })
            .attr("stroke", colorHideLine) // just sketched... update wil fix colors
            .style("stroke-width", lineWidthCircle)
          // streight down
          var theColumns2 = svg.selectAll("ColunnSegment2")
            .data(dataCircles)
            .enter()
            .append("line")
            .attr("class", "Colunn")
            .attr("x1", function (d) { return x(d.chemShift); })
            .attr("x2", function (d) { return x(d.chemShift); })
            .attr("y1", function (d) { return pointingLineColum; })
            .attr("y2", function (d) { return height; })
            .attr("stroke", colorHideLine) // just sketched... update wil fix colors
            .style("stroke-width", lineWidthCircle)

          // Lines
          function path(d) {

            // var pathOx = listOfChemicalShifts.map(function(p) { return x(d[p]); });
            console.log(JSON.stringify(d))
            const y1 = yJs(d.Jvalue);
            const y2 = yJs(d.JvalueShifted);
            //const horizontalShiftX = 0.01;
            const horizontalShiftX = 2;
            var usedHorizontalShiftX = eval(horizontalShiftX);
            const cs1 = spreadPositionsZZ[d.indexColumn1 - 1];
            const cs2 = spreadPositionsZZ[d.indexColumn2 - 1];
            if (cs1 > cs2) {
              var usedHorizontalShiftX = eval(- usedHorizontalShiftX);
            }
            const x1 = ((cs1));
            const x2 = ((cs2));
            const x1p = ((cs1) + usedHorizontalShiftX);
            const x2p = ((cs2) - usedHorizontalShiftX);
            /*
            if (d.chemShift1 > d.chemShift2) {
               var usedHorizontalShiftX = eval(- usedHorizontalShiftX);
             } const x1 = x(eval(d.chemShift1));
             const x2 = x(eval(d.chemShift2));
             const x1p = x(eval(d.chemShift1) + usedHorizontalShiftX);
             const x2p = x(eval(d.chemShift2) - usedHorizontalShiftX);
 */
            const combine = [[x1, y1], [x1p, y2], [x2p, y2], [x2, y1]];
            var Gen = d3.line();
            /*Gen.attr("d", d3.line()
                    .x(function(d) { return x(pathOx) })
               .y(function(d) { return yJs(pathOy) })
             )*/
            return Gen(combine);
          }
          /*
          function pathx(d) {
            console.log("pathx")
            console.log(JSON.stringify(d))
             console.log("pathxo")
            console.log(JSON.stringify(listOfChemicalShifts.map(function(p) { return x(p); })))
               return listOfChemicalShifts.map(function(p) { return x(p); });
          }
          function pathy(d) {
            console.log("pathy")
            console.log(JSON.stringify(d))
            console.log("pathyo")
            console.log(JSON.stringify(listOfChemicalShifts.map(function(p) { return yJs(d[p]); })))
               return listOfChemicalShifts.map(function(p) { return yJs(d[p]); });
          }
          */
          // Draw the lines
          console.log("HERE");

          function spread(spreadDelta, smallSpace) {

            for (i = 0; i < spreadDelta.length; i++) {
              const curDelta = spreadDelta[i];
              if (curDelta < smallSpace) {
                const spreadFull = (smallSpace - curDelta);
                var spreadleft = spreadFull / 2.0;
                // try shift left (1 of 3)
                for (j = i - 1; j >= 0; j -= 1) {
                  const curExtraSpace = (spreadDelta[j] - smallSpace);
                  if (curExtraSpace > 0.0) {
                    if (curExtraSpace > spreadleft) {
                      spreadDelta[j] -= spreadleft;
                      spreadDelta[i] += spreadleft;
                      spreadleft = 0;
                    } else {
                      spreadDelta[j] -= curExtraSpace;
                      spreadDelta[i] += curExtraSpace;
                      spreadleft -= curExtraSpace;
                    }
                  }
                }
                // work left over
                var spreadRight = spreadFull - spreadleft;
                // try shift right (2 of 3)
                for (j = i + 1; j < spreadDelta.length; j += 1) {
                  const curExtraSpace = (spreadDelta[j] - smallSpace);
                  if (curExtraSpace > 0.0) {
                    if (curExtraSpace > spreadRight) {
                      spreadDelta[j] -= spreadRight;
                      spreadDelta[i] += spreadRight;
                      spreadRight = 0;
                    } else {
                      spreadDelta[j] -= curExtraSpace;
                      spreadDelta[i] += curExtraSpace;
                      spreadRight -= curExtraSpace;
                    }
                  }
                }
                // work left over (rare but there may be a left over....)
                if (spreadRight > 0.0) {
                  spreadleft = spreadRight;
                  // try shift left (3 of 3)
                  for (j = i - 1; j >= 0; j -= 1) {
                    const curExtraSpace = (spreadDelta[j] - smallSpace);
                    if (curExtraSpace > 0.0) {
                      if (curExtraSpace > spreadleft) {
                        spreadDelta[j] -= spreadleft;
                        spreadDelta[i] += spreadleft;
                        spreadleft = 0;
                      } else {
                        spreadDelta[j] -= curExtraSpace;
                        spreadDelta[i] += curExtraSpace;
                        spreadleft -= curExtraSpace;
                      }
                    }
                  }
                }
                // Done 3/3
              }
            }
            return spreadDelta;
          }

          function updateColumns() {
            spreadPositions = [];
            spreadDelta = [];
            for (i = 0; i < dataCircles.length; i++) {
              var returnValue = 0.0;
              const curChemShift = dataCircles.map(function (d) { return d.chemShift; })
              const curChrem = curChemShift[i];
              if (leftPosColumns[i] < x(curChrem)) {
                if (rightPosColumns[i] > x(curChrem)) {
                  returnValue = x(curChrem);
                } else {
                  returnValue = rightPosColumns[i];
                }
              } else {
                returnValue = leftPosColumns[i];
              }
              spreadPositions.push(returnValue);
              if (i > 0) {
                spreadDelta.push(returnValue - spreadPositions[i - 1]);
              }
            }
            console.log("spreadPositions  " + JSON.stringify(spreadPositions))
            console.log("spreadDelta  " + JSON.stringify(spreadDelta))
            // See if need to seprated in the central region.
            spreadDelta = spread(spreadDelta, smallSpace);


            for (i = 0; i < spreadDelta.length; i++) {
              spreadPositions[i + 1] = spreadPositions[i] + spreadDelta[i];
            }
            theColumns1
              .transition().duration(1000)
              .attr("x1", function (d) {
                return spreadPositions[d.MyIndex];
              })
              .attr("x2", function (d) {
                return x(d.chemShift);
              })
              .attr("stroke", function (d) {
                if (
                  (x(d.chemShift) > 0.0) &&
                  (x(d.chemShift) < width)) {
                  return colorShowLine;
                } else {
                  return colorHideLine;
                }
              })
            theColumns2
              .transition().duration(1000)
              .attr("x1", function (d) {
                return x(d.chemShift);
              })
              .attr("x2", function (d) {
                return x(d.chemShift);
              })
              .attr("stroke", function (d) {
                if (
                  (x(d.chemShift) > 0.0) &&
                  (x(d.chemShift) < width)) {
                  return colorShowLine;
                } else {
                  return colorHideLine;
                }
              })

            theDots
              .transition().duration(1000)
              .attr("cx", function (d) {
                return spreadPositions[d.MyIndex];
              })
            return spreadPositions;
          }

          var spreadPositionsZZ = updateColumns();

          var theLinesW = svg
            .selectAll("myPath222")
            .attr("class", "lineW")
            .data(jGraphData)
            .enter()
            .append("path")
            .attr("class", function (d) { return "line " + d.Label }) // 2 class for each line: 'line' and the group name
            //.attr("d", function (d) { return d3.line()(listOfChemicalShifts.map(function(p) { return [x(p), yJs(d[p])]; })); })
            .attr("d", path)
            .style("stroke-width", lineWidth)
            /*.attr("d", d3.line()
              //.x(pathx)
              .x(function(d){ listOfChemicalShifts.map(function(p) { return x(p); }); })
              //.y(pathy)
              .y(function(d){ listOfChemicalShifts.map(function(p) { return yJs(d[p]); }) })
            )*/
            .style("fill", "none")
            .style("stroke", function (d) { return (color(d.Label)) })
            .style("opacity", 0.5)
            .on("mouseover", highlight)
            .on("mouseleave", doNotHighlight)

          console.log("HERE=============")

          // Add the brushing
          line
            .append("g")
            .attr("class", "brush")
            .call(brush);

          // A function that set idleTimeOut to null
          var idleTimeout
          function idled() { idleTimeout = null; }



          // A function that update the chart for given boundaries
          function updateChart() {
            console.log("Function updateChart ...===========")

            // What are the selected boundaries?
            extent = d3.event.selection

            // If no selection, back to initial coordinate. Otherwise, update X axis domain
            if (!extent) {
              if (!idleTimeout) return idleTimeout = setTimeout(idled, 350); // This allows to wait a little bit
              x.domain([
                d3.max(chemShift, function (d) { return +d.chemShift; }),
                d3.min(chemShift, function (d) { return +d.chemShift; })
              ])
            } else {
              x.domain([
                x.invert(extent[0]),
                x.invert(extent[1])
              ])
              line.select(".brush").call(brush.move, null) // This remove the grey brush area as soon as the selection has been done
            }

            // Update axis and line position
            xAxis.transition().duration(1000).call(d3.axisBottom(x))
            //xAxis2.transition().duration(1000).call(d3.axisBottom(x))

            line
              .select('.lineG')
              .transition().duration(1000)
              .attr("d", d3.line()
                .x(function (d) { return x(d.chemShift) })
                .y(function (d) { return y(d.value) })
              )
            /*
// old
          theDots
            .transition().duration(1000)
            .attr("cx", function (d) { return x(d.chemShift); })
// experimental....
            theDots
            .transition().duration(1000)
            .attr("cx", function (d) { return leftPosColumns[d.MyIndex]; })
            */
            // complex....

            spreadPositionsZZ = updateColumns();



            theLinesW
              //.select('.lineW')
              .transition().duration(1000)
              .attr("d", path)
            /*
                        console.log("x2Line grasss :" + JSON.stringify(
                          (dataCircles.map(function (d) {
                            //console.log("ch " + d.MyIndex);
                            //  console.log("x " + x(d.MyIndex));
                            return d.index;
                          }))
                        ))
            */

            //.attr("cx", x(5.555))
            /*   console.log(JSON.stringify(
                 (theDots.attr("cx"))
               ))
   
   */

            /*       console.log("chem :" + JSON.stringify(
                     (dataCircles.map(function (d) {
                       // console.log("ch" + d.chemShift);
                       return d.chemShift;
                     }))
                   ))
                   console.log("index :" + JSON.stringify(
                     (dataCircles.map(function (d) {
                       //console.log("ch " + d.MyIndex);
                       //  console.log("x " + x(d.MyIndex));
                       return d.index;
                     }))
                   ))
       */
          }
          // If user double click, reinitialize the chart
          svg.on("dblclick", function () {
            x.domain([d3.max(chemShift, function (d) { return +d.chemShift; }), d3.min(chemShift, function (d) { return +d.chemShift; })])
            xAxis.transition().call(d3.axisBottom(x))

            line
              .select('.line')
              .transition()
              .attr("d", d3.line()
                .x(function (d) { return x(d.chemShift) })
                .y(function (d) { return y(d.value) })
              )
          });


        })
    })


  </script>
  <h4>J Graph</h4>
  <p> Demo2. </p>
</body>

</html>