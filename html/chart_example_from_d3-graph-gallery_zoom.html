<html lang="en">
<div id="my_dataviz"></div>

<head>
  <meta charset="utf-8" />
  <script src="https://d3js.org/d3.v4.js"></script>
</head>

<body>
  <script>

    // set the dimensions and margins of the graph
    var margin = { top: 10, right: 30, bottom: 30, left: 60 };
    var bodyWidth = 500;
    var bodyHeight = 450;
    var lineWidth = 1.5;
    var maxScaleJ = 22.0;
    var ratioOccupyJgraph = 1.0 / 6.0;
    var circleRadius = 5;
    //if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
    if (/Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
      circleRadius = 15;
      margin = { top: 10, right: 10, bottom: 30, left: 10 }; // For vertical
      bodyWidth = 800;
      bodyHeight = 1000; // Not good when horizontal....
      lineWidth = 5;
      ratioOccupyJgraph = 1.0 / 2.0;
    }
    var circleRadiusSmall = circleRadius / 2;

    var width = bodyWidth - margin.left - margin.right;
    var height = bodyHeight - margin.top - margin.bottom;
    var heightJscale = height * ratioOccupyJgraph;

    var lineWidthCircle = lineWidth;
    var lineWidthCircleSmall = lineWidth / 2;
    
    var preferedDistanceInPtBetweenColumns = 2.0 * (circleRadius) + lineWidthCircle; // In pt
    var bottomJGraphYposition = heightJscale;
    var pointingLineColum = bottomJGraphYposition + 20;

      // append the svg object to the body of the page
      var svg = d3.select("#my_dataviz")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");
      d3.csv("./andro.csv", function (jGraphData) {
        // get chemical shifts from lines... should come from other source !
        var arrayColumns = [];
        var unassignedCouplings = []; // marked with label "noAssignement" in file
        var theAssignedCouplings = []; 
        {
          var curChemShiftToReplace = [];
          var indexArray = [];
          curChemShiftToReplace = jGraphData.map(function (d) { return d.chemShift1; })
          indexArray = jGraphData.map(function (d) { return d.indexColumn1; })
          label = jGraphData.map(function (d) { return d.Label; })
          Jvalue = jGraphData.map(function (d) { return d.Jvalue; })
          //index 1
          for (i = 0; i < curChemShiftToReplace.length; i++) {
            const index = indexArray[i];
            arrayColumns[index - 1] = curChemShiftToReplace[i];
            if (label[i] == "noAssignement") {
              unassignedCouplings.push({Jvalue: +Jvalue[i], colNumber: (index - 1) })
            } else {
              theAssignedCouplings.push({Jvalue: +Jvalue[i], colNumber: (index - 1) })
            }
          }
          // index 2
          curChemShiftToReplace = jGraphData.map(function (d) { return d.chemShift2; })
          indexArray = jGraphData.map(function (d) { return d.indexColumn2; })
          for (i = 0; i < indexArray.length; i++) {
            const index = indexArray[i];
            arrayColumns[index - 1] = curChemShiftToReplace[i];
            if (label[i] == "noAssignement") {
              unassignedCouplings.push({Jvalue: +Jvalue[i], colNumber: (index - 1) })
            } else {
              theAssignedCouplings.push({Jvalue: +Jvalue[i], colNumber: (index - 1) })
            }
          }
        }
        console.log("unassignedCouplings :" + JSON.stringify(unassignedCouplings))
        console.log("arrayColumns1 " + arrayColumns);

        // sort by decreasing values
        var len = arrayColumns.length;
        var indices = new Array(len);
        for (var i = 0; i < len; ++i) indices[i] = i;
        indices.sort(function (a, b) { return arrayColumns[a] < arrayColumns[b] ? 1 : arrayColumns[a] > arrayColumns[b] ? -1 : 0; });
      //  console.log("arrayColumns indices " + indices);
       // console.log("arrayColumns2 " + arrayColumns);
        //arrayColumns.sort().reverse();
        var indices2 = new Array(len);
        for (var i = 0; i < len; ++i) indices2[indices[i]] = i;
        var indices3 = new Array(len); for (var i = 0; i < len; ++i) indices3[i] = indices[i];
      //  console.log("arrayColumns indices2 " + indices2);
      //  console.log("arrayColumns indices3 " + indices3);

        // renumber index jGraphData(from 0 instread of 1 and decreasing chemical shift)
        for (var i = 0; i < jGraphData.length; ++i) {
                //  console.log("arrayColumnsTTTT  " + i + " " + jGraphData[i].indexColumn1);
          jGraphData[i].indexColumn1 = indices2[jGraphData[i].indexColumn1 - 1];
          jGraphData[i].indexColumn2 = indices2[jGraphData[i].indexColumn2 - 1];
        }

        var dataColumns = [];
        for (i = 0; i < arrayColumns.length; i++) {
          dataColumns.push({
            'chemShift': arrayColumns[indices[i]],
            'MyIndex': i,
          });
        }

        var dataUnassignedCoupCircles = [];
        for (i = 0; i < unassignedCouplings.length; i++) {
          const inInd = indices2[unassignedCouplings[i].colNumber];
          dataUnassignedCoupCircles.push({
           'chemShift': arrayColumns[inInd],
            'value': unassignedCouplings[i].Jvalue,
            'MyIndex': inInd,
          });
        }

        var dataAssignedCoupCircles = [];
        for (i = 0; i < theAssignedCouplings.length; i++) {
          const inInd = indices2[theAssignedCouplings[i].colNumber];
          dataAssignedCoupCircles.push({
           'chemShift': arrayColumns[inInd],
            'value': theAssignedCouplings[i].Jvalue,
            'MyIndex': inInd,
          });
        }


        // Make list of positions accoding to size of jGraphData
        const numberItem = arrayColumns.length;  //
        var smallSpace = width / (numberItem + 1); // five items, six spaces
        if (smallSpace > preferedDistanceInPtBetweenColumns) {
          smallSpace = preferedDistanceInPtBetweenColumns;
        }

        var leftPosColumns = [];
        var rightPosColumns = [];
        for (i = 0; i < numberItem; i++) {
          const curPosLeft = (i + 0.5) * smallSpace;
          const curPosRight = width - ((numberItem - i) - 0.5) * smallSpace;
          leftPosColumns.push(curPosLeft);
          rightPosColumns.push(curPosRight);
        }

        console.log("Left pos :" + JSON.stringify(leftPosColumns))
        console.log("Right pos :" + JSON.stringify(rightPosColumns))

        var color = d3.scaleOrdinal()
          .domain(["sefsdosa", "versifsdcolor", "vigdfginica", "asdf"]) // colors do not need to match the ones of the file only the numver in the file matters
          // .range([ "#440154ff", "#21908dff", "#fde725ff", "red"]) // fourth color
          .range(["orange", "green", "blue", "red", "#440154ff", "#21908dff", "#fde725ff", "orange", "cyan", "magenta", "black", "gray"]) // fourth color
        //listOfChemicalShifts = ["chemShift1","chemShift2"]
        // listOfPosition = ["JvalueShif","JvalueShifted","y3","y4"]
        /*
               for (var key in dataLines[0]) {
               listOfChemicalShifts.push(key)
          }
          for (var key in dataLines[0]) {
               listOfChemicalShifts.push(key)
          }
          listOfChemicalShifts.pop()
        */
        // Highlight the specie that is hovered
        var highlight = function (d) {

        selected_specie = d.Label
        // first every group turns grey
        d3.selectAll(".line")
          .transition().duration(200)
          .style("stroke", "black")
          .style("opacity", "0.2")
        // Second the hovered specie takes its color
        d3.selectAll("." + selected_specie)
          .transition().duration(200)
          .style("stroke", color(selected_specie))
          .style("opacity", "1")
      }

      // Unhighlight
      var doNotHighlight = function (d) {
        d3.selectAll(".line")
          .transition().duration(200).delay(1000)
          .style("stroke", function (d) { return (color(d.Label)) })
          .style("opacity", "1")
      }

      d3.csv("./Androsten_forMult_analysis.csv",
        // format variables:
        function (d) {
          return { chemShift: d.x, value: d.y }
        },

        function (chemShift) {
          // Add X axis 
          var x = d3.scaleLinear()
            .domain([
              d3.max(chemShift, function (d) { return +d.chemShift; }),
              d3.min(chemShift, function (d) { return +d.chemShift; })
            ])
            .range([0, width]);
          xAxis = svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));

          // Add Y axis2
          var yJs = d3.scaleLinear()
            .domain([0, maxScaleJ])
            .range([heightJscale, 0.0]);
          yAxisn = svg.append("g")
            // .attr("transform", function(d) { return "translate(" + x(5.5) + ")"; })
            .call(d3.axisLeft(yJs).ticks(3));

          yAxisn2 = svg.append("g")
            .attr("transform", function (d) { return "translate(" + (width) + ")"; })
            .call(d3.axisRight(yJs).ticks(3))
            ;

          let dimensions = [1, 1.2, 1.3, 2, 3, 5];

          var yn = {}
          for (i in dimensions) {
            name = dimensions[i]
            yn[name] = d3.scaleLinear()
              .domain([0.0, 22.0]) // --> Same axis range for each group
              // --> different axis range for each group --> .domain( [d3.extent(data, function(d) { return +d[name]; })] )
              .range([height / 3.0, height / 6.0]);
          }
          // Add Y axis
          var y = d3.scaleLinear()
            .domain([0, d3.max(chemShift, function (d) { return +d.value; })])
            .range([height, 0]);
          //yAxis = svg.append("g") .call(d3.axisLeft(y));

          // Add a clipPath: everything out of this area won't be drawn.
          var clip = svg.append("defs").append("svg:clipPath")
            .attr("id", "clip")
            .append("svg:rect")
            .attr("width", width)
            .attr("height", height)
            .attr("x", 0)
            .attr("y", 0);

          // Add brushing
          var brush = d3.brushX()                   // Add the brush feature using the d3.brush function
            .extent([[0, 0], [width, height]])  // initialize the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
            .on("end", updateChart)               // Each time the brush selection changes, trigger the 'updateChart' function

          // Create the line variable: where both the line and the brush take place
          var line = svg.append('g')
            .attr("clip-path", "url(#clip)")

          // Add the spectrum
          line.append("path")
            .datum(chemShift)
            .attr("class", "lineG")  // add the class line to be able to modify this line later on.
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            // .attr("stroke", "red")
            .attr("stroke-width", lineWidth)
            .attr("d", d3.line()
              .x(function (d) { return x(d.chemShift) })
              .y(function (d) { return y(d.value) })
            )

            // level of tickLine
          var dataTicksLines = [
            { Jval: 0 },
            { Jval: 5 },
            { Jval: 10 },
            { Jval: 15 },
            { Jval: 20 },
          ];

          var theTicksLines = svg.selectAll("tickLines")
            .data(dataTicksLines)
            .enter()
            .append("line")
            .attr("class", "Grid")
            .attr("x1", 0)
            .attr("y1", function (d) { return yJs(d.Jval); })
            .attr("x2", width)
            .attr("y2", function (d) { return yJs(d.Jval); })
            .attr("stroke", "#CCCCCC")
            .style("stroke-width", lineWidth)

         
          // Columns
          const colorShowLine = "#CCCCCC";
          const colorHideLine = "#EEEEEE00";
          // oblique
          var theColumns1 = svg.selectAll("columnns")
            .data(dataColumns)
            .enter()
            .append("line")
            .attr("class", "ColunnSegment1")
            .attr("x1", function (d) { return x(d.chemShift); })
            .attr("x2", function (d) { return x(d.chemShift); })
            .attr("y1", function (d) { return bottomJGraphYposition; })
            .attr("y2", function (d) { return pointingLineColum; })
            .attr("stroke", colorHideLine) // just sketched... update wil fix colors
            .style("stroke-width", lineWidthCircle)
          // streight down
          var theColumns2 = svg.selectAll("ColunnSegment2")
            .data(dataColumns)
            .enter()
            .append("line")
            .attr("class", "Colunn")
            .attr("x1", function (d) { return x(d.chemShift); })
            .attr("x2", function (d) { return x(d.chemShift); })
            .attr("y1", function (d) { return pointingLineColum; })
            .attr("y2", function (d) { return height; })
            .attr("stroke", colorHideLine) // just sketched... update wil fix colors
            .style("stroke-width", lineWidthCircle)


          // Lines
          function path(d) {

            // var pathOx = listOfChemicalShifts.map(function(p) { return x(d[p]); });
            console.log(JSON.stringify(d))
            const y1 = yJs(d.Jvalue);
            const y2 = yJs(d.JvalueShifted);
            //const horizontalShiftX = 0.01;
            const horizontalShiftX = 2;
            var usedHorizontalShiftX = eval(horizontalShiftX);
            const cs1 = spreadPositionsZZ[d.indexColumn1];
            const cs2 = spreadPositionsZZ[d.indexColumn2];
            if (cs1 > cs2) {
              var usedHorizontalShiftX = eval(- usedHorizontalShiftX);
            }
            const x1 = ((cs1));
            const x2 = ((cs2));
            const x1p = ((cs1) + usedHorizontalShiftX);
            const x2p = ((cs2) - usedHorizontalShiftX);
            /*
            if (d.chemShift1 > d.chemShift2) {
               var usedHorizontalShiftX = eval(- usedHorizontalShiftX);
             } const x1 = x(eval(d.chemShift1));
             const x2 = x(eval(d.chemShift2));
             const x1p = x(eval(d.chemShift1) + usedHorizontalShiftX);
             const x2p = x(eval(d.chemShift2) - usedHorizontalShiftX);
 */
            const combine = [[x1, y1], [x1p, y2], [x2p, y2], [x2, y1]];
            var Gen = d3.line();
            /*Gen.attr("d", d3.line()
                    .x(function(d) { return x(pathOx) })
               .y(function(d) { return yJs(pathOy) })
             )*/
            return Gen(combine);
          }
          /*
          function pathx(d) {
            console.log("pathx")
            console.log(JSON.stringify(d))
             console.log("pathxo")
            console.log(JSON.stringify(listOfChemicalShifts.map(function(p) { return x(p); })))
               return listOfChemicalShifts.map(function(p) { return x(p); });
          }
          function pathy(d) {
            console.log("pathy")
            console.log(JSON.stringify(d))
            console.log("pathyo")
            console.log(JSON.stringify(listOfChemicalShifts.map(function(p) { return yJs(d[p]); })))
               return listOfChemicalShifts.map(function(p) { return yJs(d[p]); });
          }
          */

          function getSpread(spreadDelta, smallSpace) {
            // determine how to spead objects to avoid contacts
            // there muss be anough space for this function to work
            for (i = 0; i < spreadDelta.length; i++) {
              const curDelta = spreadDelta[i];
              if (curDelta < smallSpace) {
                const spreadFull = (smallSpace - curDelta);
                var spreadleft = spreadFull / 2.0;
                // try shift left (1 of 3)
                for (j = i - 1; j >= 0; j -= 1) {
                  const curExtraSpace = (spreadDelta[j] - smallSpace);
                  if (curExtraSpace > 0.0) {
                    if (curExtraSpace > spreadleft) {
                      spreadDelta[j] -= spreadleft;
                      spreadDelta[i] += spreadleft;
                      spreadleft = 0;
                    } else {
                      spreadDelta[j] -= curExtraSpace;
                      spreadDelta[i] += curExtraSpace;
                      spreadleft -= curExtraSpace;
                    }
                  }
                }
                // work left over
                var spreadRight = spreadFull - spreadleft;
                // try shift right (2 of 3)
                for (j = i + 1; j < spreadDelta.length; j += 1) {
                  const curExtraSpace = (spreadDelta[j] - smallSpace);
                  if (curExtraSpace > 0.0) {
                    if (curExtraSpace > spreadRight) {
                      spreadDelta[j] -= spreadRight;
                      spreadDelta[i] += spreadRight;
                      spreadRight = 0;
                    } else {
                      spreadDelta[j] -= curExtraSpace;
                      spreadDelta[i] += curExtraSpace;
                      spreadRight -= curExtraSpace;
                    }
                  }
                }
                // work left over (rare but there may be a left over....)
                if (spreadRight > 0.0) {
                  spreadleft = spreadRight;
                  // try shift left (3 of 3)
                  for (j = i - 1; j >= 0; j -= 1) {
                    const curExtraSpace = (spreadDelta[j] - smallSpace);
                    if (curExtraSpace > 0.0) {
                      if (curExtraSpace > spreadleft) {
                        spreadDelta[j] -= spreadleft;
                        spreadDelta[i] += spreadleft;
                        spreadleft = 0;
                      } else {
                        spreadDelta[j] -= curExtraSpace;
                        spreadDelta[i] += curExtraSpace;
                        spreadleft -= curExtraSpace;
                      }
                    }
                  }
                }
                // Done 3/3
              }
            }
            return spreadDelta;
          }

 // Circles
          var theDots = svg.selectAll("dots")
            .data(dataUnassignedCoupCircles)
            .enter()
            .append("circle")
            .attr("class", "circle")
            .attr("cx", function (d) { return x(d.chemShift); })
            .attr("cy", function (d) { return yJs(d.value); })
            .attr("r", circleRadius)
            .style("fill", "white")
            .attr("stroke", "black")
            .style("stroke-width", lineWidthCircle)

           // Dots
          var theDots2 = svg.selectAll("dots")
            .data(dataAssignedCoupCircles)
            .enter()
            .append("circle")
            .attr("class", "circle")
            .attr("cx", function (d) { return x(d.chemShift); })
            .attr("cy", function (d) { return yJs(d.value); })
            .attr("r", circleRadiusSmall)
            .style("fill", "gray")
            .attr("stroke", "black")
            .style("stroke-width", lineWidthCircleSmall)

          function updateColumns() {
            spreadPositions = [];
            spreadDelta = [];
            for (i = 0; i < dataColumns.length; i++) {
              var returnValue = 0.0;
              const curChemShift = dataColumns.map(function (d) { return d.chemShift; })
              const curChem = curChemShift[i];
              if (leftPosColumns[i] < x(curChem)) {
                if (rightPosColumns[i] > x(curChem)) {
                  returnValue = x(curChem);
                } else {
                  returnValue = rightPosColumns[i];
                }
              } else {
                returnValue = leftPosColumns[i];
              }
              spreadPositions.push(returnValue);
              if (i > 0) {
                spreadDelta.push(returnValue - spreadPositions[i - 1]);
              }
            }
            console.log("spreadPositions  " + JSON.stringify(spreadPositions))
            console.log("spreadDelta  " + JSON.stringify(spreadDelta))
            // See if need to seprated in the central region.
            spreadDelta = getSpread(spreadDelta, smallSpace);
            console.log("spreadDeltaspreadDelta  " + JSON.stringify(spreadDelta))

            for (i = 0; i < spreadDelta.length; i++) {
              spreadPositions[i + 1] = spreadPositions[i] + spreadDelta[i];
            }

            theColumns1
              .transition().duration(1000)
              .attr("x1", function (d) {
                return spreadPositions[d.MyIndex];
              })
              .attr("x2", function (d) {
                return x(d.chemShift);
              })
              .attr("stroke", function (d) {
                if (
                  (x(d.chemShift) > 0.0) &&
                  (x(d.chemShift) < width)) {
                  return colorShowLine;
                } else {
                  return colorHideLine;
                }
              })

            theColumns2
              .transition().duration(1000)
              .attr("x1", function (d) {
                return x(d.chemShift);
              })
              .attr("x2", function (d) {
                return x(d.chemShift);
              })
              .attr("stroke", function (d) {
                if (
                  (x(d.chemShift) > 0.0) &&
                  (x(d.chemShift) < width)) {
                  return colorShowLine;
                } else {
                  return colorHideLine;
                }
              })

            theDots
              .transition().duration(1000)
              .attr("cx", function (d) {
                return spreadPositions[d.MyIndex];
              })
            theDots2
              .transition().duration(1000)
              .attr("cx", function (d) {
                return spreadPositions[d.MyIndex];
              })

            return spreadPositions;
          }

          var spreadPositionsZZ = updateColumns();

          var theLinesW = svg
            .selectAll("myPath222")
            .attr("class", "lineW")
            .data(jGraphData)
            .enter()
            .append("path")
            .attr("class", function (d) { return "line " + d.Label }) // 2 class for each line: 'line' and the group name
            //.attr("d", function (d) { return d3.line()(listOfChemicalShifts.map(function(p) { return [x(p), yJs(d[p])]; })); })
            .attr("d", path)
            .style("stroke-width", lineWidth)
            /*.attr("d", d3.line()
              //.x(pathx)
              .x(function(d){ listOfChemicalShifts.map(function(p) { return x(p); }); })
              //.y(pathy)
              .y(function(d){ listOfChemicalShifts.map(function(p) { return yJs(d[p]); }) })
            )*/
            .style("fill", "none")
            .style("stroke", function (d) { return (color(d.Label)) })
            .style("opacity", 0.5)
            .on("mouseover", highlight)
            .on("mouseleave", doNotHighlight)

          // Add the brushing
          line
            .append("g")
            .attr("class", "brush")
            .call(brush);

          // A function that set idleTimeOut to null
          var idleTimeout
          function idled() { idleTimeout = null; }

          // A function that update the chart for given boundaries
          function updateChart() {
            console.log("Function updateChart ...===========")

            // What are the selected boundaries?
            extent = d3.event.selection

            // If no selection, back to initial coordinate. Otherwise, update X axis domain
            if (!extent) {
              if (!idleTimeout) return idleTimeout = setTimeout(idled, 350); // This allows to wait a little bit
              x.domain([
                d3.max(chemShift, function (d) { return +d.chemShift; }),
                d3.min(chemShift, function (d) { return +d.chemShift; })
              ])
            } else {
              x.domain([
                x.invert(extent[0]),
                x.invert(extent[1])
              ])
              line.select(".brush").call(brush.move, null) // This remove the grey brush area as soon as the selection has been done
            }

            // Update axis and line position
            xAxis.transition().duration(1000).call(d3.axisBottom(x))
            //xAxis2.transition().duration(1000).call(d3.axisBottom(x))

            line
              .select('.lineG')
              .transition().duration(1000)
              .attr("d", d3.line()
                .x(function (d) { return x(d.chemShift) })
                .y(function (d) { return y(d.value) })
              )


            spreadPositionsZZ = updateColumns();

            theLinesW
              //.select('.lineW')
              .transition().duration(1000)
              .attr("d", path)
            /*
                        console.log("x2Line grasss :" + JSON.stringify(
                          (dataCircles.map(function (d) {
                            //console.log("ch " + d.MyIndex);
                            //  console.log("x " + x(d.MyIndex));
                            return d.index;
                          }))
                        ))
            */

            //.attr("cx", x(5.555))
            /*   console.log(JSON.stringify(
                 (theDots.attr("cx"))
               ))
   
   */

            /*       console.log("chem :" + JSON.stringify(
                     (dataCircles.map(function (d) {
                       // console.log("ch" + d.chemShift);
                       return d.chemShift;
                     }))
                   ))
                   console.log("index :" + JSON.stringify(
                     (dataCircles.map(function (d) {
                       //console.log("ch " + d.MyIndex);
                       //  console.log("x " + x(d.MyIndex));
                       return d.index;
                     }))
                   ))
       */
          }
          // If user double click, reinitialize the chart
          svg.on("dblclick", function () {
            x.domain([d3.max(chemShift, function (d) { return +d.chemShift; }), d3.min(chemShift, function (d) { return +d.chemShift; })])
            xAxis.transition().call(d3.axisBottom(x))

            line
              .select('.line')
              .transition()
              .attr("d", d3.line()
                .x(function (d) { return x(d.chemShift) })
                .y(function (d) { return y(d.value) })
              )
          });


        })
    })


  </script>
  <h4>J Graph</h4>
  <p> Demo2. </p>
</body>

</html>