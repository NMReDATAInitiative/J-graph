<html lang="en">
<div id="my_dataviz"></div>

<head>
  <meta charset="utf-8" />
  <script src="https://d3js.org/d3.v4.js"></script>
</head>

<body>
  <script>

    // set the dimensions and margins of the graph
    var margin = { top: 10, right: 30, bottom: 30, left: 60 };
    var bodyWidth = 500;
    var bodyHeight = 450;
    var lineWidth = 1.5;
    var maxScaleJ = 22.0;
    var ratioOccupyJgraph = 1.0 / 6.0;

    //if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
    if ( /Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
      margin = { top: 10, right: 10, bottom: 30, left: 10 }; // For vertical
      bodyWidth = 800;
      bodyHeight = 1000; // Not good when horizontal....
      lineWidth = 5;
      ratioOccupyJgraph = 1.0 / 2.0;
    }
    
    var width = bodyWidth - margin.left - margin.right;
    var height = bodyHeight - margin.top - margin.bottom;
    var heightJscale = height * ratioOccupyJgraph;

var lineWidthCircle = lineWidth;
var circleRadius = 5;
    var preferedDistanceInPtBetweenColumns = 2.0 * (circleRadius) + lineWidthCircle; // In pt


    // append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform",
        "translate(" + margin.left + "," + margin.top + ")");
    d3.csv("./andro.csv", function (jGraphData) {


      var dataCircles = [ // sorted by decreading values, index gives position
          { chemShift: 8.5, value: 17.5, MyIndex: 0 },
          { chemShift: 7.5, value: 17.4, MyIndex: 1 },
          { chemShift: 6.5, value: 17.2, MyIndex: 2 },
          { chemShift: 5.7, value: 17.1, MyIndex: 3 },
          { chemShift: 5.62, value: 7.4 ,MyIndex: 4},
          { chemShift: 5.61, value: 2.42 , MyIndex: 5},
          { chemShift: 5.601, value: 2.421 , MyIndex: 6},
          { chemShift: 5.60, value: 2.422 , MyIndex: 7},
          { chemShift: 4, value: 2.422 , MyIndex: 8},
          { chemShift: 1, value: 2.422 , MyIndex: 9},
          { chemShift: 0.13, value: 2.422 , MyIndex: 10},
          { chemShift: 0.12, value: 8.422 , MyIndex: 11}, 
          { chemShift: 0.11, value: 17.422 , MyIndex: 12},
          ]

      // Make list of positions accoding to size of jGraphData
      const numberItem = dataCircles.length;  // this will be size of jGraphData
      var smallSpace = width / (numberItem + 1); // five items, six spaces
      if (smallSpace > preferedDistanceInPtBetweenColumns) {
        smallSpace = preferedDistanceInPtBetweenColumns;
      }
      console.log("=====================")

      var leftPosColumns = [];
      var rightPosColumns = [];
      for (i = 0; i < numberItem; i++) {
        const curPosLeft = (i + 0.5) * smallSpace;
        const curPosRight = width - ((numberItem - i) - 0.5) * smallSpace;
        leftPosColumns.push(curPosLeft);
        rightPosColumns.push(curPosRight);
      } 
      
      console.log("Left pos :" + JSON.stringify(leftPosColumns)) 
      console.log("Right pos :" + JSON.stringify(rightPosColumns))

      var color = d3.scaleOrdinal()
        .domain(["sefsdosa", "versifsdcolor", "vigdfginica", "asdf"]) // colors do not need to match the ones of the file only the numver in the file matters
        // .range([ "#440154ff", "#21908dff", "#fde725ff", "red"]) // fourth color
        .range(["orange", "green", "blue", "red"]) // fourth color
      //listOfChemicalShifts = ["chemShift1","chemShift2"]
      // listOfPosition = ["JvalueShif","JvalueShifted","y3","y4"]
      /*
        for (var key in dataLines[0]) {
             listOfChemicalShifts.push(key)
        }
        for (var key in dataLines[0]) {
             listOfChemicalShifts.push(key)
        }
        listOfChemicalShifts.pop()
      */
      // Highlight the specie that is hovered
      var highlight = function (d) {

        selected_specie = d.Label
        // first every group turns grey
        d3.selectAll(".line")
          .transition().duration(200)
          .style("stroke", "black")
          .style("opacity", "0.2")
        // Second the hovered specie takes its color
        d3.selectAll("." + selected_specie)
          .transition().duration(200)
          .style("stroke", color(selected_specie))
          .style("opacity", "1")
      }

      // Unhighlight
      var doNotHighlight = function (d) {
        d3.selectAll(".line")
          .transition().duration(200).delay(1000)
          .style("stroke", function (d) { return (color(d.Label)) })
          .style("opacity", "1")
      }

      d3.csv("./Androsten_forMult_analysis.csv",
        // format variables:
        function (d) {
          return { chemShift: d.x, value: d.y }
        },

        function (chemShift) {
          // Add X axis 
          var x = d3.scaleLinear()
            .domain([
              d3.max(chemShift, function (d) { return +d.chemShift; }),
              d3.min(chemShift, function (d) { return +d.chemShift; })
            ])
            .range([0, width]);
          xAxis = svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));

          // Add Y axis2
          var yJs = d3.scaleLinear()
            .domain([0, maxScaleJ])
            .range([heightJscale, 0.0]);
          yAxisn = svg.append("g")
            // .attr("transform", function(d) { return "translate(" + x(5.5) + ")"; })
            .call(d3.axisLeft(yJs).ticks(3));

          yAxisn2 = svg.append("g")
            .attr("transform", function (d) { return "translate(" + (width) + ")"; })
            .call(d3.axisRight(yJs).ticks(3))
            ;

          let dimensions = [1, 1.2, 1.3, 2, 3, 5];

          var yn = {}
          for (i in dimensions) {
            name = dimensions[i]
            yn[name] = d3.scaleLinear()
              .domain([0.0, 22.0]) // --> Same axis range for each group
              // --> different axis range for each group --> .domain( [d3.extent(data, function(d) { return +d[name]; })] )
              .range([height / 3.0, height / 6.0]);
          }
          // Add Y axis
          var y = d3.scaleLinear()
            .domain([0, d3.max(chemShift, function (d) { return +d.value; })])
            .range([height, 0]);
          //yAxis = svg.append("g") .call(d3.axisLeft(y));

          // Add a clipPath: everything out of this area won't be drawn.
          var clip = svg.append("defs").append("svg:clipPath")
            .attr("id", "clip")
            .append("svg:rect")
            .attr("width", width)
            .attr("height", height)
            .attr("x", 0)
            .attr("y", 0);

          // Add brushing
          var brush = d3.brushX()                   // Add the brush feature using the d3.brush function
            .extent([[0, 0], [width, height]])  // initialize the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
            .on("end", updateChart)               // Each time the brush selection changes, trigger the 'updateChart' function

          // Create the line variable: where both the line and the brush take place
          var line = svg.append('g')
            .attr("clip-path", "url(#clip)")

          // Add the spectrum
          line.append("path")
            .datum(chemShift)
            .attr("class", "lineG")  // add the class line to be able to modify this line later on.
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            // .attr("stroke", "red")
            .attr("stroke-width", lineWidth)
            .attr("d", d3.line()
              .x(function (d) { return x(d.chemShift) })
              .y(function (d) { return y(d.value) })
            )

          

          // Circles
          var theDots = svg.selectAll("dots")
            .data(dataCircles)
            .enter()
            .append("circle")
            .attr("class", "circle")
            .attr("cx", function (d) { return x(d.chemShift); })
            .attr("cy", function (d) { return yJs(d.value); })
            .attr("r", circleRadius)
            .style("fill", "#69b3a2")
            .attr("stroke", "red")
            .style("stroke-width", lineWidthCircle)

          var dataTicksLines = [
            { Jval: 0 },
            { Jval: 5 },
            { Jval: 10 },
            { Jval: 15 },
            { Jval: 20 },
          ]

          // Circles
          var theTicksLines = svg.selectAll("tickLines")
            .data(dataTicksLines)
            .enter()
            .append("line")
            .attr("class", "Grid")
            .attr("x1", 0)
            .attr("y1", function (d) { return yJs(d.Jval); })
            .attr("x2", width)
            .attr("y2", function (d) { return yJs(d.Jval); })
            .attr("stroke", "#00000020")
            .style("stroke-width", lineWidth)

          svg.append("line")
            .attr("x1", x(0)).attr("y1", yJs(5))
            .attr("x2", x(10)).attr("y2", yJs(5))
            .style("stroke", "11223388");

          // Lines
          function path(d) {

            // var pathOx = listOfChemicalShifts.map(function(p) { return x(d[p]); });
            console.log(JSON.stringify(d))
            const y1 = yJs(d.Jvalue);
            const y2 = yJs(d.JvalueShifted);
            const horizontalShiftX = 0.01;
            var usedHorizontalShiftX = eval(horizontalShiftX);
            if (d.chemShift1 > d.chemShift2) {
              var usedHorizontalShiftX = eval(- usedHorizontalShiftX);
            }

            const x1 = x(eval(d.chemShift1));
            const x2 = x(eval(d.chemShift2));
            const x1p = x(eval(d.chemShift1) + usedHorizontalShiftX);
            const x2p = x(eval(d.chemShift2) - usedHorizontalShiftX);

            const combine = [[x1, y1], [x1p, y2], [x2p, y2], [x2, y1]];
            var Gen = d3.line();
            /*Gen.attr("d", d3.line()
                    .x(function(d) { return x(pathOx) })
                    .y(function(d) { return yJs(pathOy) })
             )*/
            return Gen(combine);
          }
          /*
          function pathx(d) {
            console.log("pathx")
            console.log(JSON.stringify(d))
             console.log("pathxo")
            console.log(JSON.stringify(listOfChemicalShifts.map(function(p) { return x(p); })))
               return listOfChemicalShifts.map(function(p) { return x(p); });
          }
          function pathy(d) {
            console.log("pathy")
            console.log(JSON.stringify(d))
            console.log("pathyo")
            console.log(JSON.stringify(listOfChemicalShifts.map(function(p) { return yJs(d[p]); })))
               return listOfChemicalShifts.map(function(p) { return yJs(d[p]); });
          }
          */
          // Draw the lines
          console.log("HERE")

          var theLinesW = svg
            .selectAll("myPath222")
            .attr("class", "lineW")
            .data(jGraphData)
            .enter()
            .append("path")
            .attr("class", function (d) { return "line " + d.Label }) // 2 class for each line: 'line' and the group name
            //.attr("d", function (d) { return d3.line()(listOfChemicalShifts.map(function(p) { return [x(p), yJs(d[p])]; })); })
            .attr("d", path)
            .style("stroke-width", lineWidth)
            /*.attr("d", d3.line()
              //.x(pathx)
              .x(function(d){ listOfChemicalShifts.map(function(p) { return x(p); }); })
              //.y(pathy)
              .y(function(d){ listOfChemicalShifts.map(function(p) { return yJs(d[p]); }) })
            )*/
            .style("fill", "none")
            .style("stroke", function (d) { return (color(d.Label)) })
            .style("opacity", 0.5)
            .on("mouseover", highlight)
            .on("mouseleave", doNotHighlight)

          console.log("HERE=============")

          // Add the brushing
          line
            .append("g")
            .attr("class", "brush")
            .call(brush);

          // A function that set idleTimeOut to null
          var idleTimeout
          function idled() { idleTimeout = null; }

          // A function that update the chart for given boundaries
          function updateChart() {

            // What are the selected boundaries?
            extent = d3.event.selection

            // If no selection, back to initial coordinate. Otherwise, update X axis domain
            if (!extent) {
              if (!idleTimeout) return idleTimeout = setTimeout(idled, 350); // This allows to wait a little bit
              x.domain([
                d3.max(chemShift, function (d) { return +d.chemShift; }), 
                d3.min(chemShift, function (d) { return +d.chemShift; })
              ])
            } else {
              x.domain([
                x.invert(extent[0]),
                x.invert(extent[1])
              ])
              line.select(".brush").call(brush.move, null) // This remove the grey brush area as soon as the selection has been done
            }

            // Update axis and line position
            xAxis.transition().duration(1000).call(d3.axisBottom(x))
            //xAxis2.transition().duration(1000).call(d3.axisBottom(x))

            line
              .select('.lineG')
              .transition().duration(1000)
              .attr("d", d3.line()
                .x(function (d) { return x(d.chemShift) })
                .y(function (d) { return y(d.value) })
              )
              /*
// old
            theDots
              .transition().duration(1000)
              .attr("cx", function (d) { return x(d.chemShift); })
// experimental....
              theDots
              .transition().duration(1000)
              .attr("cx", function (d) { return leftPosColumns[d.MyIndex]; })
              */
// complex....
              theDots
              .transition().duration(1000)
                .attr("cx", function (d) {
                  if (leftPosColumns[d.MyIndex] < x(d.chemShift)) {
                    if (rightPosColumns[d.MyIndex] > x(d.chemShift)) {
                      return x(d.chemShift);
                    } else {
                      return rightPosColumns[d.MyIndex];
                    }
                  } else {
                    return leftPosColumns[d.MyIndex];
                  }
                })


            //.attr("cx", x(5.555))
            console.log("Function updateChart ...===========")
            console.log("calc di" + x(13.333333))
            console.log(JSON.stringify(
              (theDots.attr("cx"))
            ))
        


            console.log("chem :" + JSON.stringify(
              (dataCircles.map(function (d) {
               // console.log("ch" + d.chemShift);
                return d.chemShift;
              }))
            ))
            console.log("index :" + JSON.stringify(
              (dataCircles.map(function (d) {
                console.log("ch " + d.MyIndex);
                console.log("x " + x(d.MyIndex));
                console.log("del() " + del[d.MyIndex]);
                return d.index;
              }))
            ))
            console.log("fff :" + JSON.stringify(del))
           
            theLinesW
              //.select('.lineW')
              .transition().duration(1000)
              .attr("d", path)


          }
          // If user double click, reinitialize the chart
          svg.on("dblclick", function () {
            x.domain([d3.max(chemShift, function (d) { return +d.chemShift; }), d3.min(chemShift, function (d) { return +d.chemShift; })])
            xAxis.transition().call(d3.axisBottom(x))

            line
              .select('.line')
              .transition()
              .attr("d", d3.line()
                .x(function (d) { return x(d.chemShift) })
                .y(function (d) { return y(d.value) })
              )
          });
        })
    })
  </script>
  <h4>J Graph</h4>
  <p> Demo2. </p>
</body>

</html>